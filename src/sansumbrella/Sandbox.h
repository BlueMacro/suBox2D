/*
 * Copyright (c) 2010â€”2013, David Wicks
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once
#include <Box2D/Box2D.h>
#include "Box2DRenderer.h"

namespace cinder
{ // forward declaration
  class TriMesh2d;
}

namespace sansumbrella
{
  /**
  Sandbox creates a mapping between the window and the physics world.
  It also keeps track of the objects used with the b2World for debug drawing,
  stepping the simulation, and basic mouse interaction.

  Sandbox enables easy RAII management of physics objects through the manage()
  methods that return smart pointers to the elements in the b2World. This makes
  it straightforward to consider a physics body as a member of some other project
  component and properly dispose of it once the component falls out of scope.

  When setting the world scale, keep in mind that Box2D is designed to simulate
  objects between 10cm and 10m in size. With the Sandbox's default scale, that
  translates to screen sizes between 10 and 1000 points (DPI-agnostic pixels).

  TODO:
  Standardize on using world coordinates for adding elements.
  Add method for setting gl matrices based on world scale
  (perhaps non-member, non-friend that uses the scale).
  Camera controls seem like they should be someone else's job
  */

  typedef std::unique_ptr<b2Body, std::function<void(b2Body*)>> unique_body_ptr;
  typedef std::unique_ptr<b2Joint, std::function<void(b2Joint*)>> unique_joint_ptr;

  class Sandbox
  {
  public:
    Sandbox();
    ~Sandbox() = default;
    //! Run the Box2D physics timestep
    void step();
    //! have a look at what's in the physics system (scaled up to screen space)
    void debugDraw();

    //! Create a boundary rectangle in screen coordinates
    b2Body* createBoundaryRect( ci::Rectf screen_bounds, float thickness=1.0f );
    //! Create a box using screen coordinates
    b2Body* createBox( const ci::Vec2f &pos, const ci::Vec2f &size );
    //! Create a circle using screen coordinates
    b2Body* createCircle( const ci::Vec2f &pos, float radius );
    //! Create a shape from a TriMesh2d, as could be generated by ci::Triangulator
    b2Body* createShape( const ci::Vec2f &centroid, const ci::TriMesh2d &mesh, float scale=1.0f );
    //! Performs simple triangulation of \a hull_vertices to create a hull around \a centroid
    //! pass the outside vertices like you would to a TRIANGLE_FAN, using world coordinates
    b2Body* createFanShape( const ci::Vec2f &centroid, const std::vector<b2Vec2> &hull_vertices );
    //! Create a box2d body with multiple fixtures from the given definitions
    b2Body* createBody( const b2BodyDef &body_def, const std::vector<b2FixtureDef> &fixture_defs );
    //! Create a box2d body from the given definitions
    b2Body* createBody( const b2BodyDef &body_def, const b2FixtureDef &fixture_def );

    //! Manage the lifetime of a b2Body with a unique_ptr and a custom deleter
    auto manage( b2Body *body ) -> unique_body_ptr
    { return { body, [this](b2Body *b){ destroyBody( b ); } }; }
    //! Manage the lifetime of a b2Joint with a unique_ptr and a custom deleter
    auto manage( b2Joint *joint ) -> unique_joint_ptr
    { return { joint, [this](b2Joint *j){ destroyJoint( j ); } }; }

    //! Direct access to the box2d world
    b2World& getWorld()
    { return mWorld; }

    // Convenience methods for some b2world functions

    //! Destroy \a body
    inline void     destroyBody( b2Body *body )
    { mWorld.DestroyBody( body ); }
    //! Destroy \a joint
    inline void     destroyJoint( b2Joint *joint )
    { mWorld.DestroyJoint( joint ); }
    //! Returns the number of bodies being simulated
    inline int32    getBodyCount()
    { return mWorld.GetBodyCount(); }
    //! Returns the number of contacts generated between bodies
    inline int32    getContactCount()
    { return mWorld.GetContactCount(); }
    //! Returns the Box2D body list (a b2Body linked-list)
    inline b2Body*  getBodyList()
    { return mWorld.GetBodyList(); }

    //! Set the world gravity, default=(0, 10)
    inline void setGravity( const b2Vec2 &gravity ){ mWorld.SetGravity( gravity ); }
    //! Set number of velocity iterations used per step(), default=8
    inline void setVelocityIterations( int vi ){ mVelocityIterations = vi; }
    //! Set number of position iterations used per step(), default=3
    inline void setPositionIterations( int pi ){ mPositionIterations = pi; }
    //! Set how much time elapses with each physics simulation step
    inline void setTimeStep( float hz ){ mTimeStep = hz; }


    //! set the filter function for your objects
    void setContactFilter( const b2ContactFilter &filter );

    //! enable user interaction through a b2MouseJoint
    void connectUserSignals( ci::app::WindowRef window );
    void disconnectUserSignals();

    // handle basic user interaction
    bool mouseDown( ci::app::MouseEvent &event );
    bool mouseUp( ci::app::MouseEvent &event );
    bool mouseDrag( ci::app::MouseEvent &event );

    // Conversion between screen and physics space

    //! Set the number of screen points contained in a world meter
    //! default value is 100 (1 pixel == 1 centimeter)
    void setPointsPerMeter( float points );
    //! Set the number of meters represented per screen point
    //! Default value is 0.01
    void setMetersPerPoint( float meters );
    //! Return the number of points per meter
    inline float getPointsPerMeter() const { return mPointsPerMeter; }
    inline float getMetersPerPoint() const { return mMetersPerPoint; }
    //! Convert from screen units to physical measurements
    template<typename T>
    inline T toPhysics( const T &points )
    { return points * mMetersPerPoint; }
    //! Convert from physical measurements to screen units
    template<typename T>
    inline T toPoints( const T &physical_measure )
    { return physical_measure * mPointsPerMeter; }
  private:
    int     mVelocityIterations = 8;
    int     mPositionIterations = 3;
    float   mTimeStep = 1.0f / 60.0f;
    float   mPointsPerMeter = 100.0f;
    float   mMetersPerPoint = 1.0f / mPointsPerMeter;
    // the box2d world
    b2World         mWorld = b2World( b2Vec2( 0, 10.0f ) );
    // optional contact filter (kept here to ensure it stays in scope)
    // set this if you want to control what collides with what
    b2ContactFilter mContactFilter;

    // our mouse, for simple interaction
    b2MouseJoint*   mMouseJoint = nullptr;
    Box2DRenderer   mDebugRenderer;
  };
}